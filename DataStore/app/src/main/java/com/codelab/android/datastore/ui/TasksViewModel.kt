/*
 * Copyright 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("unused", "MemberVisibilityCanBePrivate")

package com.codelab.android.datastore.ui

import androidx.lifecycle.LiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.asLiveData
import androidx.lifecycle.liveData
import androidx.lifecycle.viewModelScope
import com.codelab.android.datastore.UserPreferences
import com.codelab.android.datastore.UserPreferences.SortOrder
import com.codelab.android.datastore.data.Task
import com.codelab.android.datastore.data.TasksRepository
import com.codelab.android.datastore.data.UserPreferencesRepository
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch

/**
 * This is the data class that we use to combine the [List] of [Task] objects created from the
 * [TasksRepository.tasks] field [Flow] of our `repository` field (our [tasks] field is a [Flow] of
 * a [List] of its [Task] objects which is filtered and sorted depending on the values stored in
 * the app's [UserPreferences]) as well as the current value of the [UserPreferences.showCompleted_]
 * and [UserPreferences.sortOrder_] preferences.
 *
 * @param tasks the [List] of [Task] objects that results when our `filterSortTasks` filters and sorts
 * the field [TasksRepository.tasks] flow of [List] of [Task] objects according to the value of the
 * app's [UserPreferences].
 * @param showCompleted the value of the [Boolean] preference stored in the [UserPreferences.showCompleted_]
 * field of the [UserPreferences] field collected from the [UserPreferencesRepository.userPreferencesFlow]
 * field flow of our `userPreferencesRepository` field.
 * @param sortOrder the value of the [SortOrder] preference stored in the [UserPreferences.sortOrder_]
 * field of the [UserPreferences] field collected from the [UserPreferencesRepository.userPreferencesFlow]
 * field flow of our `userPreferencesRepository` field.
 */
data class TasksUiModel(
    val tasks: List<Task>,
    val showCompleted: Boolean,
    val sortOrder: SortOrder
)

/**
 * The [ViewModel] used by our app.
 *
 * @param repository the [TasksRepository] whose [Flow] of [List] of [Task] object field
 * [TasksRepository.tasks] we should combine with the current [UserPreferences] into a [LiveData]
 * wrapped instance of [TasksUiModel] for the UI to observe (our [tasksUiModel] field).
 * @param userPreferencesRepository the [UserPreferencesRepository] instance we should use to
 * retrieve the values in the latest [UserPreferences] flow that is returned by its field
 * [UserPreferencesRepository.userPreferencesFlow].
 */
class TasksViewModel(
    repository: TasksRepository,
    private val userPreferencesRepository: UserPreferencesRepository
) : ViewModel() {

    /**
     * TODO: Add kdoc
     */
    val initialSetupEvent: LiveData<UserPreferences> = liveData {
        emit(userPreferencesRepository.fetchInitialPreferences())
    }

    /**
     * Keep the user preferences as a stream of changes for our [tasksUiModelFlow] to use.
     */
    private val userPreferencesFlow: Flow<UserPreferences> = userPreferencesRepository.userPreferencesFlow

    /**
     * Every time the sort order, the show completed filter or the list of tasks emit, we should
     * recreate the list of tasks filtered and sorted according to the latest values. We use the
     * [combine] method to create a [Flow] of [TasksUiModel] objects from the [Flow] of [List] of
     * [Task] objects in the [TasksRepository.tasks] field of `repository` and the [Flow] of
     * [UserPreferences] objects in our [userPreferencesFlow] field with the lambda argument of
     * [combine] returning a [Flow] whose values are [TasksUiModel] objects generated by combining
     * the most recently emitted values by each flow.
     */
    private val tasksUiModelFlow: Flow<TasksUiModel> = combine(
        repository.tasks,
        userPreferencesFlow
    ) { tasks: List<Task>, userPreferences: UserPreferences ->
        return@combine TasksUiModel(
            tasks = filterSortTasks(
                tasks,
                userPreferences.showCompleted,
                userPreferences.sortOrder
            ),
            showCompleted = userPreferences.showCompleted,
            sortOrder = userPreferences.sortOrder
        )
    }

    /**
     * The [LiveData] wrapped [TasksUiModel] property created from our [Flow] of [TasksUiModel] field
     * [tasksUiModelFlow] that the UI observes in order to detect when it should update the information
     * it displays.
     */
    val tasksUiModel: LiveData<TasksUiModel> = tasksUiModelFlow.asLiveData()

    /**
     * This method filters its [List] of [Task] objects parameter [tasks] filtering out the tasks
     * whose [Task.completed] field is `true` if its [showCompleted] is `false` then returns that
     * filtered [List] sorted according to its [SortOrder] parameter [sortOrder].
     *
     * @param tasks the [List] of [Task] objects we are to filter and sort.
     * @param showCompleted if `true` completed tasks are included in the [List] of [Task] objects
     * returned (no filtering), if `false` completed tasks are omitted from the [List] of [Task]
     * objects returned.
     * @param sortOrder the [SortOrder] to apply to the [List] of [Task] objects we return.
     * @return a [List] of [Task] objects filtered according to our [showCompleted] parameter and
     * sorted according to [sortOrder] parameter created from our [List] of [Task] parameter [tasks]
     */
    private fun filterSortTasks(
        tasks: List<Task>,
        showCompleted: Boolean,
        sortOrder: SortOrder
    ): List<Task> {
        // filter the tasks
        val filteredTasks = if (showCompleted) {
            tasks
        } else {
            tasks.filter { !it.completed }
        }
        // sort the tasks
        return when (sortOrder) {
            SortOrder.UNSPECIFIED -> filteredTasks
            SortOrder.NONE -> filteredTasks
            SortOrder.BY_DEADLINE -> filteredTasks.sortedByDescending { it.deadline }
            SortOrder.BY_PRIORITY -> filteredTasks.sortedBy { it.priority }
            SortOrder.BY_DEADLINE_AND_PRIORITY -> filteredTasks.sortedWith(
                compareByDescending<Task> { it.deadline }.thenBy { it.priority }
            )
            // We shouldn't get any other values
            else -> throw UnsupportedOperationException("$sortOrder not supported")
        }
    }

    /**
     * Called to change the value of the [Boolean] preference stored as the [UserPreferences.showCompleted_]
     * field in our Proto `DataStore`. We launch a new coroutine on the [CoroutineScope] of [viewModelScope]
     * which calls the [UserPreferencesRepository.updateShowCompleted] method of our field
     * [userPreferencesRepository] with our [Boolean] parameter [show]. That method then uses the
     * `DataStore.updateData` method of our app's `DataStore` of [UserPreferences] to write this
     * value to disk.
     *
     * @param show the new value to store as the [UserPreferences.showCompleted_] field in our app's
     * Proto `DataStore` of [UserPreferences]
     */
    fun showCompletedTasks(show: Boolean) {
        viewModelScope.launch {
            userPreferencesRepository.updateShowCompleted(show)
        }
    }

    /**
     * Called to change the "Sort by deadline" part of the [SortOrder] preference stored in the
     * [UserPreferences.sortOrder_] field of our Proto `DataStore` to reflect our [Boolean] parameter
     * [enable] (`true` adds it to the [SortOrder], `false` removes it). We launch a new coroutine on
     * the [CoroutineScope] of [viewModelScope] which calls the [UserPreferencesRepository.enableSortByDeadline]
     * method of our field [userPreferencesRepository] with our [Boolean] parameter [enable]. That
     * method will store the [SortOrder.name] value stored in the [UserPreferences.sortOrder_] field
     * using the `DataStore.updateData` method of our app's `DataStore` of [UserPreferences] depending
     * on the value of [enable] and the previous value of the `SORT_ORDER` preference as follows:
     *  - [enable] is `true`: sets it to [SortOrder.BY_DEADLINE_AND_PRIORITY] if the previous value
     *  of the preference was [SortOrder.BY_PRIORITY], or to [SortOrder.BY_DEADLINE] if it was not.
     *  - [enable] is `false`: sets it to [SortOrder.BY_PRIORITY] if the previous value of the
     *  preference was [SortOrder.BY_DEADLINE_AND_PRIORITY], or to [SortOrder.NONE] if it was not.
     *
     * @param enable if `true` adds "Sort by deadline" to the sort used to sort our tasks and stores
     * it in our app's `DataStore` of [UserPreferences], if `false` removes "Sort by deadline" from the
     * sort used to sort our tasks and stores it in our app's `DataStore` of [UserPreferences]
     */
    fun enableSortByDeadline(enable: Boolean) {
        viewModelScope.launch {
            userPreferencesRepository.enableSortByDeadline(enable)
        }
    }

    /**
     * Called to change the "Sort by priority" part of the [SortOrder] preference stored in the
     * [UserPreferences.sortOrder_] field of our Proto `DataStore` to reflect our [Boolean] parameter
     * [enable] (`true` adds it to the [SortOrder], `false` removes it). We launch a new coroutine on
     * the [CoroutineScope] of [viewModelScope] which calls the [UserPreferencesRepository.enableSortByPriority]
     * method of our field [userPreferencesRepository] with our [Boolean] parameter [enable]. That
     * method will store the [SortOrder.name] value stored in the [UserPreferences.sortOrder_] field
     * using the `DataStore.updateData` method of our app's `DataStore` of [UserPreferences] depending
     * on the value of [enable] and the previous value of the `SORT_ORDER` preference as follows:
     *  - [enable] is `true`: sets it to [SortOrder.BY_DEADLINE_AND_PRIORITY] if the previous value
     *  of the preference was [SortOrder.BY_DEADLINE], or to [SortOrder.BY_PRIORITY] if it was not.
     *  - [enable] is `false`: sets it to [SortOrder.BY_DEADLINE] if the previous value of the
     *  preference was [SortOrder.BY_DEADLINE_AND_PRIORITY], or to [SortOrder.NONE] if it was not.
     *
     * @param enable if `true` adds "Sort by priority" to the sort used to sort our tasks and stores
     * it in our app's `DataStore` of [UserPreferences], if `false` removes "Sort by priority" from the
     * sort used to sort our tasks and stores it in our app's `DataStore` of [UserPreferences]
     */
    fun enableSortByPriority(enable: Boolean) {
        viewModelScope.launch {
            userPreferencesRepository.enableSortByPriority(enable)
        }
    }}

/**
 * The [ViewModelProvider.Factory] used by [ViewModelProvider] when it needs to create an instance
 * of [TasksViewModel]. It passes our [TasksRepository] parameter [repository] and our
 * [UserPreferencesRepository] parameter to the [TasksViewModel] constructor.
 *
 * @param repository the [TasksRepository] instance to use to retrieve the [List] of [Task] objects
 * that are to be displayed by the UI.
 * @param userPreferencesRepository the [UserPreferencesRepository] that provides access to our
 * app's Proto `DataStore` of [UserPreferences].
 */
class TasksViewModelFactory(
    private val repository: TasksRepository,
    private val userPreferencesRepository: UserPreferencesRepository
) : ViewModelProvider.Factory {

    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(TasksViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return TasksViewModel(repository, userPreferencesRepository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
