package com.example.android.baselineprofile

import androidx.benchmark.macro.MacrobenchmarkScope
import androidx.benchmark.macro.junit4.BaselineProfileRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.uiautomator.By
import androidx.test.uiautomator.Direction
import androidx.test.uiautomator.UiObject2
import androidx.test.uiautomator.Until
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

/**
 * This test class generates a basic startup baseline profile for the target package.
 *
 * We recommend you start with this but add important user flows to the profile to improve their
 * performance. Refer to the
 * [baseline profile documentation](https://d.android.com/topic/performance/baselineprofiles)
 * for more information.
 *
 * You can run the generator with the "Generate Baseline Profile" run configuration in Android
 * Studio or the equivalent `generateBaselineProfile` gradle task:
 * ```
 * ./gradlew :app:generateReleaseBaselineProfile
 * ```
 * The run configuration runs the Gradle task and applies filtering to run only the generators.
 *
 * Check
 * [documentation](https://d.android.com/topic/performance/benchmarking/macrobenchmark-instrumentation-args)
 * for more information about available instrumentation arguments.
 *
 * After you run the generator, you can verify the improvements running the [StartupBenchmarks]
 * benchmark.
 *
 * When using this class to generate a baseline profile, only API 33+ or rooted API 28+ are
 * supported.
 *
 * The minimum required version of androidx.benchmark to generate a baseline profile is 1.2.0.
 */
@RunWith(AndroidJUnit4::class)
@LargeTest
class BaselineProfileGenerator {

    /**
     * This rule allows one to generate Baseline Profiles.
     *
     * The [BaselineProfileRule] provides methods to interact with the Baseline Profile generation
     * process. It's crucial for generating and managing baseline profiles which are essential for
     * improving application startup and runtime performance.
     *
     * Use this rule in instrumented tests to:
     *
     * 1.  **Generate Baseline Profiles:** Define code paths to be included in the profile,
     * allowing the system to optimize these paths during installation.
     * 2. **Verify Profile Generation:**  Ensure that the generated profile includes the expected
     * code paths.
     *
     * **How to use:**
     *
     * 1. Annotate the property with `@get:Rule`.
     * 2. Instantiate `BaselineProfileRule`.
     * 3. Use `collectBaselineProfile()` method within a test function to start profile generation.
     *
     * **Key Considerations:**
     *
     * - Profile generation can take a significant amount of time.
     * - The device must have enough storage to accommodate the generated profile.
     * - Ensure the package name is correct for the app being profiled.
     * - It's recommended to run the profile generation on a physical device if possible.
     */
    @get:Rule
    val rule: BaselineProfileRule = BaselineProfileRule()

    /**
     * Generates a baseline profile for the target application.
     *
     * This function defines the critical user journey (CUJ) of the app and records
     * the interactions to generate a baseline profile. This profile is used by the
     * Android system to optimize the app's performance, especially during startup and
     * other common user interactions.
     *
     * The profile is generated by interacting with the app in a way that represents
     * typical user behavior. The recorded interactions are then translated into a
     * profile file that is used during ahead-of-time (AOT) compilation.
     *
     * The following steps are performed during profile generation:
     * 1. **Retrieve Target App ID:** The application ID of the target app is read from
     *    the instrumentation arguments. This ensures that the correct app is targeted
     *    for profile generation. If the targetAppId is not passed, an exception is thrown.
     * 2. **Collect Profile Data:** Using the `BaselineProfileRule.collect()` method,
     *    profile data is collected while interacting with the app. The collected data
     *    includes class and method usage.
     * 3. **Include in Startup Profile:** The `includeInStartupProfile` flag is set to
     *    `true` to indicate that the collected data should be primarily used for
     *    startup optimization.
     */
    @Test
    fun generate() {
        // The application id for the running build variant is read from the instrumentation arguments.
        rule.collect(
            packageName = InstrumentationRegistry.getArguments().getString("targetAppId")
                ?: throw Exception("targetAppId not passed as instrumentation runner arg"),

            // See: https://d.android.com/topic/performance/baselineprofiles/dex-layout-optimizations
            includeInStartupProfile = true
        ) {
            // This block defines the app's critical user journey. Here we are interested in
            // optimizing for app startup. But you can also navigate and scroll through your most important UI.

            // Start default activity for your app
            pressHome()
            startActivityAndWait()

            // TODO Write more interactions to optimize advanced journeys of your app.
            // For example:
            // 1. Wait until the content is asynchronously loaded
            waitForAsyncContent()
            // 2. Scroll the feed content
            scrollSnackListJourney()
            // 3. Navigate to detail screen
            goToSnackDetailJourney()

            // Check UiAutomator documentation for more information how to interact with the app.
            // https://d.android.com/training/testing/other-components/ui-automator
        }
    }

    /**
     * Waits for asynchronous content to be fully rendered within the application under test.
     *
     * This function specifically targets a scenario where a list (identified by resource ID
     * "snack_list") is loaded asynchronously and then populates its items (identified by resource
     * ID "snack_collection").
     *
     * It performs the following steps:
     * 1. Waits for the main list container ("snack_list") to appear in the view hierarchy, with a
     * timeout of 5 seconds.
     * 2. Once the list is present, it obtains a reference to it.
     * 3. Then it waits for at least one item ("snack_collection") to be rendered within the list
     * container, also with a 5-second timeout.
     *
     * This ensures that the content is not only present in the UI but also has had time to fully
     * render its elements, preventing tests from interacting with incomplete or partially loaded
     * data.
     *
     * Note: both "snack_list" and "snack_collection" are set on the Composable by a
     * `Modifier.testTag`
     */
    fun MacrobenchmarkScope.waitForAsyncContent() {
        device.wait(Until.hasObject(By.res("snack_list")), 5_000)
        val contentList: UiObject2 = device.findObject(By.res("snack_list"))
        // Wait until a snack collection item within the list is rendered.
        contentList.wait(Until.hasObject(By.res("snack_collection")), 5_000)
    }

    /**
     * Scrolls the snack list view down using a fling gesture.
     *
     * This function performs the following actions:
     * 1. Locates the `LazyColumn` representing the snack list using its `Modifier.testTag`
     * ("snack_list").
     * 2. Sets a gesture margin to avoid interfering with the system's gesture navigation. This
     * prevents accidental triggering of back or home gestures when flinging. The margin is set
     * to 1/5th of the device's display width on each side.
     * 3. Executes a fling gesture downwards on the snack list. This simulates a user swiping
     * quickly down on the list to scroll through its items.
     * 4. Waits for the device to become idle after the fling. This ensures that the fling
     * animation and any resulting layout changes are completed before proceeding to the next step
     * in the benchmark.
     *
     * This function is designed for use within a Macrobenchmark to measure the performance of
     * scrolling the snack list view.
     *
     * Note: "snack_list" is set on the Composable by a `Modifier.testTag`
     *
     * @receiver The [MacrobenchmarkScope] within which this journey is being executed.
     */
    fun MacrobenchmarkScope.scrollSnackListJourney() {
        val snackList: UiObject2 = device.findObject(By.res("snack_list"))
        // Set gesture margin to avoid triggering gesture navigation.
        snackList.setGestureMargin(device.displayWidth / 5)
        snackList.fling(Direction.DOWN)
        device.waitForIdle()
    }

    /**
     * Navigates to the snack detail screen from the snack list screen.
     *
     * This function performs the following actions:
     * 1. **Locates the snack list:** It finds the `LazyColumn` that displays the list of snacks
     * using the `Modifier.testTag` "snack_list".
     * 2. **Finds the snack items:** It then locates all the individual snack items within the list
     * using the `Modifier.testTag` "snack_item".
     * 3. **Selects a snack:** It selects a snack item based on the current iteration of the
     * benchmark.
     *     - If it's the first iteration (or `iteration` is null), it will select the first
     *     snack (index 0).
     *     - In subsequent iterations, it cycles through the list of snacks. For instance, on the
     *     second iteration, it selects the second snack (index 1), and so on.
     *     - If the number of iterations exceeds the number of snacks, it wraps around (using the
     *     modulo operator `%`) to reuse the snacks from the beginning of the list.
     * 4. **Clicks the snack:** It simulates a click on the selected snack item, initiating the
     * navigation to the detail screen.
     * 5. **Waits for the detail screen:** It waits until the snack list screen is no longer
     * visible (i.e., it has been replaced by the detail screen). This is done using `device.wait()`
     * and `Until.gone()`, which waits for the element with the resource ID "snack_list" to
     * disappear from the screen. It allows up to 5 seconds (5_000 milliseconds) for this to happen.
     *
     * This function is designed to be used within a macrobenchmark to measure the performance of
     * navigating from the snack list to the snack detail screen.
     *
     * @receiver MacrobenchmarkScope The scope in which the benchmark is executed.
     */
    fun MacrobenchmarkScope.goToSnackDetailJourney() {
        val snackList: UiObject2 = device.findObject(By.res("snack_list"))
        val snacks: List<UiObject2> = snackList.findObjects(By.res("snack_item"))
        // Select snack from the list based on running iteration.
        val index: Int = (iteration ?: 0) % snacks.size
        snacks[index].click()
        // Wait until the screen is gone = the detail is shown.
        device.wait(Until.gone(By.res("snack_list")), 5_000)
    }
}